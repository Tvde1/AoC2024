using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace AoC.SourceGenerators;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
[SuppressMessage("MicrosoftCodeAnalysisReleaseTracking", "RS2008:Enable analyzer release tracking")]
public class PuzzleInputSourceGenerator : IIncrementalGenerator
{
    private const string PuzzleLocationAssembly = "AoC.Console";

    private const string Namespace = "AoC.Console.Generated";
    private const string GeneratedPuzzleInterfaceName = "IGeneratedPuzzle";

    public const string GeneratedPuzzleInterfaceSourceCode = $$"""
                                                      // <auto-generated/>

                                                      namespace {{Namespace}}
                                                      {
                                                          public interface {{GeneratedPuzzleInterfaceName}}
                                                          {
                                                              int Year { get; }
                                                              int Day { get; }
                                                              
                                                              string RunPart1();
                                                              string RunPart2();
                                                              void RunBenchmark();
                                                          }
                                                      }
                                                      """;
    private static string CreatePuzzleClassName(int year, int day) => $"Puzzle{year:D4}D{day:D2}";

    private static string CreatePuzzleProviderSourceCode(
        int year, int day, string puzzleClassName, string puzzleExecutingNamespace, string puzzleExecutingTypeName, string inputPath,
        string rawInput, string puzzlePart1Type, string puzzlePart2Type) =>
        $$"""""""""""""
          // <auto-generated/>
          
          using {{puzzleExecutingNamespace}};
          
          namespace {{Namespace}}
          {
              public class {{puzzleClassName}} : {{GeneratedPuzzleInterfaceName}}
              {
                  private readonly {{puzzleExecutingTypeName}} _puzzle = new();
                  
                  public int Year => {{year}};
                  public int Day => {{day}};
                  
                  public string RunPart1()
                  {
                      return _puzzle.PrettyPrint(_puzzle.SolvePart1(RawInput));
                  }
                  
                  public string RunPart2()
                  {
                      return _puzzle.PrettyPrint(_puzzle.SolvePart2(RawInput));
                  }
              
                  // Input from from {{inputPath}}.
                  private const string RawInput = 
          """"""""""""
          {{rawInput}}
          """""""""""";
          
                  public void RunBenchmark()
                  {
                      BenchmarkDotNet.Running.BenchmarkRunner.Run<Benchmark>();
                  }
                            
                  [BenchmarkDotNet.Attributes.SimpleJob]
                  [BenchmarkDotNet.Attributes.HtmlExporter, BenchmarkDotNet.Attributes.MarkdownExporter]
                  [BenchmarkDotNet.Attributes.MemoryDiagnoser(false)]
                  public class Benchmark
                  {
                      private readonly {{puzzleExecutingTypeName}} _puzzle = new();
                        
                      [BenchmarkDotNet.Attributes.Benchmark]
                      public {{puzzlePart1Type}} Part1() => _puzzle.SolvePart1(RawInput);
                        
                      [BenchmarkDotNet.Attributes.Benchmark]
                      public {{puzzlePart2Type}} Part2() => _puzzle.SolvePart2(RawInput);
                  }
              }
          }
          """"""""""""";

    public static string CreatePuzzlesList(List<string> puzzlesList) =>
        string.Join(", ", puzzlesList.Select(p => $"new {p}()"));

    public static string PuzzleCollectionSourceCode(List<string> puzzlesList) =>
        $$"""
          // <auto-generated/>

          namespace {{Namespace}}
          {
              public static class PuzzleCollection
              {
                  public static List<{{GeneratedPuzzleInterfaceName}}> Puzzles => [
                      {{CreatePuzzlesList(puzzlesList)}}
                  ];
              }
          }
          """;


    private static readonly DiagnosticDescriptor NoInputDescriptor = new(
        "AC0001",
        "No input",
        "No input file was found for {0} day {1}",
        "AoC",
        DiagnosticSeverity.Warning,
        true);

    private static readonly DiagnosticDescriptor DuplicatePuzzleDescriptor = new(
        "AC0002",
        "Duplicate puzzle descriptor",
        "The puzzle descriptor of year {0} day {1} was found twice",
        "AoC",
        DiagnosticSeverity.Warning,
        true);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{GeneratedPuzzleInterfaceName}.g.cs",
            SourceText.From(GeneratedPuzzleInterfaceSourceCode, Encoding.UTF8)));

        // TOOD use AdditionalTextsProvider to get the input files

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax cds && HasPuzzleAttribute(cds),
                (ctx, _) => TransformPuzzleAttribute(ctx));

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right!));
    }

    private static bool HasPuzzleAttribute(ClassDeclarationSyntax classDeclarationSyntax) =>
        classDeclarationSyntax.AttributeLists.Any(al => al.Attributes.Any(a => a.Name.ToString() == "Puzzle"));

    private static (ClassDeclarationSyntax, int Year, int Day) TransformPuzzleAttribute(GeneratorSyntaxContext context)
    {
        var classDec = (ClassDeclarationSyntax)context.Node;

        var attr = classDec.AttributeLists.SelectMany(static y => y.Attributes)
            .First(z => z.Name.ToString() == "Puzzle");

        var year = int.Parse(attr.ArgumentList!.Arguments[0].Expression.ToString());
        var day = int.Parse(attr.ArgumentList.Arguments[1].Expression.ToString());

        return (classDec, year, day);
    }

    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [Report] attribute) changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="classDeclarations">Nodes annotated with the [Report] attribute that trigger the generate action.</param>
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<(ClassDeclarationSyntax PuzzleClass, int Year, int Day)> classDeclarations)
    {
        var generatorPath = GetFilePath();

        var directoryName = Path.GetDirectoryName(generatorPath);

        var groupedClassDeclarations = classDeclarations.GroupBy(x => new { x.Year, x.Day })
            .ToList();

        var duplicatePuzzles = groupedClassDeclarations.Where(x => x.Count() > 1).SelectMany(x => x);
        foreach (var puzzle in duplicatePuzzles)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(DuplicatePuzzleDescriptor,
                    puzzle.PuzzleClass.GetLocation(),
                    puzzle.Year,
                    puzzle.Day));
        }

        var correctPuzzles = groupedClassDeclarations.Where(x => x.Count() == 1).SelectMany(x => x).ToList();

        var generatedPuzzleClasses = new List<string>();

        foreach (var puzzle in correctPuzzles)
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            var dayName = puzzle.Day.ToString("D2");
            var yearDayName = $"Y{puzzle.Year}D{dayName}";

            var fullPath = Path.Combine(directoryName, "..", PuzzleLocationAssembly, puzzle.Year.ToString(), "Input",
                $"Day{dayName}.txt");

            string rawInput;
            try
            {
                // Pech gehad
#pragma warning disable RS1035
                rawInput = File.ReadAllText(fullPath);
#pragma warning restore RS1035
            }
            catch
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    NoInputDescriptor,
                    puzzle.PuzzleClass.Identifier.GetLocation(),
                    puzzle.Year, puzzle.Day));

                continue;
            }

            var puzzleClassName = CreatePuzzleClassName(puzzle.Year, puzzle.Day);

            var x = puzzle.PuzzleClass.BaseList;

            var puzzlePart1Type = "string";
            var puzzlePart2Type = "string";

            foreach (var interfaceType in x.Types)
            {
                if (interfaceType.Type.GetFirstToken().Text == "IPuzzle")
                {
                    var typeArguments =((GenericNameSyntax)interfaceType.Type).TypeArgumentList;

                    puzzlePart1Type = typeArguments.Arguments.First().ToString();
                    puzzlePart2Type = typeArguments.Arguments.Last().ToString();
                }
            }

            var source = CreatePuzzleProviderSourceCode(puzzle.Year, puzzle.Day,
                puzzleClassName, GetNamespace(puzzle.PuzzleClass),
                puzzle.PuzzleClass.Identifier.Text, fullPath, rawInput,
                puzzlePart1Type, puzzlePart2Type);

            generatedPuzzleClasses.Add(puzzleClassName);

            context.AddSource($"{yearDayName}Puzzle.g.cs", source);
        }

        var collectionSource = PuzzleCollectionSourceCode(generatedPuzzleClasses);
        context.AddSource("PuzzleCollection.g.cs", collectionSource);
    }

    private static string GetFilePath([CallerFilePath] string path = null!) => path;

    public static string? GetNamespace(SyntaxNode syntaxNode)
    {
        return string.Join(".", syntaxNode
            .Ancestors()
            .OfType<BaseNamespaceDeclarationSyntax>()
            .Reverse()
            .Select(x => x.Name)
        );
    }
}